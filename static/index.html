<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>TBS Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { font-family: system-ui, sans-serif; margin: 20px; max-width: 800px; }
    #grid { display: grid; grid-auto-rows: 32px; grid-auto-columns: 32px; gap: 1px; margin: 10px 0; border: 1px solid #ccc; }
    .tile { width:32px; height:32px; display:flex; align-items:center; justify-content:center; border:1px solid #ddd; font-size:10px; position: relative; }
    .WATER { background:#7ec8e3; }
    .BLOCKED { background:#666; color:#fff; }
    .PLAIN { background:#f5f5f5; }
    .FOREST { background:#8bc34a; }
    .HILL { background:#ff9800; }
  /* Selected/current highlights on the TILE to cover full square */
  .tile.selected { box-shadow: inset 0 0 0 3px #4caf50; }
  .tile.current { box-shadow: inset 0 0 0 2px #2196f3; }
  .u { border-radius: 4px; width:30px; height:30px; display:flex; align-items:center; justify-content:center; font-weight: 600; font-size: 11px; position: relative; border: 1px solid rgba(0,0,0,0.08); z-index: 1; }
    .PLAYER { background:#4caf50; color:#fff; }
  .ENEMY { background:#7e57c2; color:#fff; }
    .NEUTRAL { background:#9e9e9e; color:#fff; }
    .dead { opacity: 0.3; }
    .panel { display:flex; gap:12px; margin: 8px 0; align-items: center; flex-wrap: wrap; }
    button { padding: 6px 12px; cursor:pointer; background: #2196f3; color: white; border: none; border-radius: 4px; }
    button:hover { background: #1976d2; }
    button:disabled { background: #ccc; cursor: not-allowed; }
    .status { background: #f5f5f5; padding: 8px; border-radius: 4px; font-size: 14px; }
    .unit-info { background: #e8f5e8; padding: 8px; border-radius: 4px; }
  .log { background: #f9f9f9; border: 1px solid #ddd; padding: 8px; height: 160px; overflow-y: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; text-align: left; }
  .log-entry { padding: 6px 8px; border-bottom: 1px dashed #e0e0e0; border-left: 3px solid transparent; white-space: pre-wrap; word-break: break-word; }
  .log-entry:last-child { border-bottom: none; }
  .log-entry.success { background: #e8f5e9; color: #1b5e20; border-left-color: #2e7d32; }
  .log-entry.warn { background: #fff8e1; color: #5d4037; border-left-color: #f9a825; }
  .log-entry.error { background: #fde7e7; color: #b71c1c; border-left-color: #d32f2f; }
    .action-btn { padding: 4px 8px; font-size: 12px; }

  /* Move/attack hints */
  .tile.move { background: #e6f4ea; box-shadow: inset 0 0 0 2px rgba(76,175,80,0.35); }
  .tile .ring { position:absolute; width:26px; height:26px; border:3px solid #ef5350; border-radius:50%; pointer-events:none; box-shadow: 0 0 6px rgba(239,83,80,0.6); z-index: 2; }
  </style>
</head>
<body>
  <h1>Turn-Based Strategy Demo</h1>

  <div id="sessions">
    <div class="panel">
      <strong>Existing Sessions</strong>
  <button id="new" type="button">New Game</button>
      <button id="refresh-sessions" class="action-btn">Refresh</button>
    </div>
    <div id="sessions-list" class="panel" style="flex-direction: column; align-items: stretch;"></div>
  </div>

  <div id="game" style="display:none;">
    <div class="panel">
      <button id="end-turn" type="button" disabled>End Turn</button>
  <button id="legal" type="button">Show Legal Actions</button>
  <button id="show-sessions" type="button">Show Sessions</button>
      <div class="status">
        <span>Session: <b id="sid">-</b></span> |
        <span>Turn: <b id="turn">-</b></span> |
        <span>Side: <b id="side">-</b></span>
      </div>
    </div>

    <div class="panel">
      <div class="unit-info">
        <span>Current Unit: <b id="current-unit">none</b></span> |
        <span>AP: <b id="ap">-</b></span> |
        <span>Selected: <b id="sel">none</b></span>
      </div>
    </div>

    <div id="grid"></div>

    <div class="log" id="log"></div>
  </div>

<script>
let SID = null;
let STATE = null;
let SELECTED = null;
let LEGAL_ACTIONS = [];
let MOVE_HINTS = new Set();
let ATTACK_HINTS = new Map(); // key: "x,y" => target unit id

async function api(path, opts={}) {
  const r = await fetch(path, {headers:{'content-type':'application/json'}, ...opts});
  if (!r.ok) throw new Error(await r.text());
  return r.json();
}

function log(msg, level) {
  const p = document.getElementById('log');
  const time = new Date().toLocaleTimeString();

  let cls = level || 'info';
  const m = String(msg).toLowerCase();
  const negatives = ['error', 'not legal', 'failed', 'invalid', 'cannot', "can't", 'out of range', 'unknown', 'missing'];
  if (!level && negatives.some(k => m.includes(k))) cls = 'error';

  const div = document.createElement('div');
  div.className = 'log-entry' + (cls && cls !== 'info' ? ' ' + cls : '');
  div.textContent = `[${time}] ${msg}`;

  if (p.firstChild) p.insertBefore(div, p.firstChild); else p.appendChild(div);
}

function updateUI() {
  document.getElementById('sid').textContent = SID || '-';
  document.getElementById('turn').textContent = STATE ? STATE.turn : '-';
  document.getElementById('side').textContent = STATE ? STATE.side_to_move : '-';
  document.getElementById('current-unit').textContent = STATE?.current_unit_id ?
    STATE.units[STATE.current_unit_id]?.name || 'unknown' : 'none';
  document.getElementById('ap').textContent = STATE?.current_unit_id ?
    STATE.units[STATE.current_unit_id]?.ap_left || 0 : '-';
  document.getElementById('sel').textContent = SELECTED && STATE?.units[SELECTED] ?
    STATE.units[SELECTED].name : 'none';

  const endTurnBtn = document.getElementById('end-turn');
  endTurnBtn.disabled = !SID;
}

async function attemptAction(action) {
  if (!SID) return false;
  try {
    const evalRes = await api(`/sessions/${SID}/evaluate`, {method:'POST', body: JSON.stringify({action})});
    if (!evalRes.legal) {
      log(`Action not legal: ${evalRes.explanation}`, 'error');
  // Clear selection and hints when illegal action happens
  SELECTED = null;
  MOVE_HINTS.clear();
  ATTACK_HINTS.clear();
  document.querySelectorAll('.tile.selected').forEach(el => el.classList.remove('selected'));
  updateUI();
  render();
      return false;
    }
    const res = await api(`/sessions/${SID}/action`, {method:'POST', body: JSON.stringify({action})});
    STATE = res.session.mission;
    log(`Action applied: ${res.explanation}`, 'success');
    updateUI();
  await fetchLegalAndComputeHints();
    render();
    return true;
  } catch (e) {
    log(`Error: ${e.message}`, 'error');
    return false;
  }
}

function showGame() {
  document.getElementById('sessions').style.display = 'none';
  document.getElementById('game').style.display = '';
}

function showSessions() {
  document.getElementById('game').style.display = 'none';
  document.getElementById('sessions').style.display = '';
}

async function refreshSessions() {
  const container = document.getElementById('sessions-list');
  container.innerHTML = '';
  try {
    const sessions = await api('/sessions');
    if (!Array.isArray(sessions) || sessions.length === 0) {
      const empty = document.createElement('div');
      empty.textContent = 'No sessions yet.';
      empty.style.color = '#666';
      container.appendChild(empty);
      return;
    }
    sessions.forEach(s => {
      const row = document.createElement('div');
      row.style.display = 'flex';
      row.style.alignItems = 'center';
      row.style.justifyContent = 'space-between';
      row.style.gap = '8px';
      row.style.padding = '6px 8px';
      row.style.border = '1px solid #eee';
      row.style.borderRadius = '4px';

      const info = document.createElement('div');
      const m = s.mission || {};
      const unitsCount = m.units ? Object.keys(m.units).length : 0;
      info.textContent = `${s.id} â€” Turn ${m.turn ?? '-'} | Side ${m.side_to_move ?? '-'} | Units ${unitsCount}`;

    const btn = document.createElement('button');
      btn.className = 'action-btn';
      btn.textContent = 'Continue';
      const doLoad = async () => {
        try {
          const sess = await api(`/sessions/${s.id}`);
          SID = sess.id;
          STATE = sess.mission;
          SELECTED = null;
          LEGAL_ACTIONS = [];
          await fetchLegalAndComputeHints();
          log(`Loaded session ${SID}`);
          updateUI();
          render();
      showGame();
      document.getElementById('game').scrollIntoView({behavior:'smooth', block:'start'});
        } catch (e) {
          log(`Error loading session: ${e.message}`, 'error');
        }
      };
      btn.onclick = doLoad;
      // Also allow clicking the row (not just the button) to load
      row.onclick = (ev) => {
        if (ev.target === btn) return; // avoid double fire
        doLoad();
      };

      row.appendChild(info);
      row.appendChild(btn);
      container.appendChild(row);
    });
  } catch (e) {
    log(`Error fetching sessions: ${e.message}`, 'error');
  }
}

document.getElementById('new').onclick = async () => {
  try {
    log('Creating new session...');
    const res = await api('/sessions', {method:'POST', body: JSON.stringify({})});
    SID = res.id;
    STATE = res.mission;
    SELECTED = null;
    LEGAL_ACTIONS = [];
    log(`Session ${SID} created`);
    updateUI();
  await fetchLegalAndComputeHints();
    render();
  showGame();
  refreshSessions();
  } catch (e) {
    log(`Error: ${e.message}`, 'error');
  }
};

document.getElementById('end-turn').onclick = async () => {
  if (!SID) return;
  try {
    log('Ending turn...');
    const action = {kind: 'END_TURN'};
    const res = await api(`/sessions/${SID}/action`, {method:'POST', body: JSON.stringify({action})});
    STATE = res.session.mission;
    SELECTED = null;
    LEGAL_ACTIONS = [];
  log(`Turn ended: ${res.explanation}`, 'success');
    updateUI();
  await fetchLegalAndComputeHints();
    render();
  } catch (e) {
    log(`Error: ${e.message}`, 'error');
  }
};

document.getElementById('legal').onclick = async () => {
  if (!SID) return;
  try {
    if (!SELECTED && STATE?.current_unit_id) SELECTED = STATE.current_unit_id;
    await fetchLegalAndComputeHints();
    render();
    console.log('Legal actions:', LEGAL_ACTIONS);
    log(`Found ${LEGAL_ACTIONS.length} legal actions`);
  } catch (e) {
    log(`Error: ${e.message}`, 'error');
  }
};

function render() {
  const g = document.getElementById('grid');
  if (!STATE) return;

  const w = STATE.map.width, h = STATE.map.height;
  g.style.gridTemplateColumns = `repeat(${w}, 32px)`;
  g.innerHTML = '';

  const idx = {};
  for (let y = 0; y < h; y++) {
    for (let x = 0; x < w; x++) {
      const t = STATE.map.tiles[y][x];
      const div = document.createElement('div');
      div.className = 'tile ' + (t.terrain || 'PLAIN');
      div.dataset.x = x;
      div.dataset.y = y;
      g.appendChild(div);
      idx[`${x},${y}`] = div;
    }
  }

  // Render units
  Object.values(STATE.units).forEach(u => {
    const d = idx[`${u.pos[0]},${u.pos[1]}`];
    if (!d) return;

    const dot = document.createElement('div');
    dot.className = 'u ' + u.side + (u.alive ? '' : ' dead');
  const base = (u.stats && u.stats.base) || {};
  const hp = (base.HP ?? base['HP'] ?? 0);
    const ap = (u.ap_left ?? 0);
    dot.innerHTML = `<div style="line-height:1.05; text-align:center;">
      <div>hp: ${hp}</div>
      <div>ap: ${ap}</div>
    </div>`;
    const allStats = [
      ['HP', hp],
      ['AP', (base.AP ?? base['AP'] ?? ap)],
      ['ATK', (base.ATK ?? base['ATK'] ?? 0)],
      ['DEF', (base.DEF ?? base['DEF'] ?? 0)],
      ['MOV', (base.MOV ?? base['MOV'] ?? 0)],
      ['RNG', (base.RNG ?? base['RNG'] ?? 0)],
      ['CRIT', (base.CRIT ?? base['CRIT'] ?? 0)],
    ].map(([k,v]) => `${k}: ${v}`).join('\n');
    dot.title = `${u.name} (${u.side})\nPos: ${u.pos[0]},${u.pos[1]}\n${allStats}`;

    // Click behavior:
    // - If a friendly unit is selected and this is an enemy, try attack (don't change selection).
    // - If this is an enemy and no selection, do nothing.
    // - Otherwise, select this (friendly) unit.
    dot.onclick = async (e) => {
      e.stopPropagation();
      if (!u.alive) return;

  const selectedUnit = SELECTED ? STATE.units[SELECTED] : null;
  const isCurrent = STATE.current_unit_id === u.id;

      // If a unit is already selected and this clicked unit is on the opposite side, try to attack instead of selecting
      if (selectedUnit && selectedUnit.alive && selectedUnit.id !== u.id && selectedUnit.side !== u.side) {
        if (selectedUnit.id !== STATE.current_unit_id) {
          log(`${selectedUnit.name} is not the active unit. It's ${STATE.units[STATE.current_unit_id]?.name}'s turn.`);
          return;
        }
        const action = { kind: 'ATTACK', attacker_id: selectedUnit.id, target_id: u.id };
        const ok = await attemptAction(action);
        if (ok) return; // Keep selection on the attacker
        return; // If illegal, stop without selecting the target
      }

      // Only allow selecting the current unit
      if (!isCurrent) {
        log(`${u.name} is not the active unit. It's ${STATE.units[STATE.current_unit_id]?.name}'s turn.`);
        return;
      }

  // Select current unit
      SELECTED = u.id;
      updateUI();
      // Remove previous tile selection and apply to this tile so the full square is highlighted
      document.querySelectorAll('.tile.selected').forEach(el => el.classList.remove('selected'));
      d.classList.add('selected');
      log(`Selected ${u.name}`);
  // After selecting, compute hints from server legal actions
  await fetchLegalAndComputeHints();
  render();
    };

    d.appendChild(dot);
  });

  // Highlight current unit
  if (STATE.current_unit_id) {
    const currentUnit = STATE.units[STATE.current_unit_id];
    if (currentUnit) {
      const currentTile = idx[`${currentUnit.pos[0]},${currentUnit.pos[1]}`];
      if (currentTile) {
        currentTile.classList.add('current');
      }
    }
  }

  // Persist selection highlight across renders
  if (SELECTED && STATE.units[SELECTED]) {
    const su = STATE.units[SELECTED];
    const selTile = idx[`${su.pos[0]},${su.pos[1]}`];
    if (selTile) selTile.classList.add('selected');
  }

  // Render move/attack hints
  MOVE_HINTS.forEach(key => {
    const el = idx[key];
    if (el) el.classList.add('move');
  });
  ATTACK_HINTS.forEach((uid, key) => {
    const el = idx[key];
    if (el) {
      const ring = document.createElement('div');
      ring.className = 'ring';
      el.appendChild(ring);
    }
  });

  // Handle tile clicks for movement/attacks
  g.querySelectorAll('.tile').forEach(tile => {
    tile.onclick = async () => {
  if (!SID || !SELECTED) return;

      const to = [parseInt(tile.dataset.x), parseInt(tile.dataset.y)];
      const selectedUnit = STATE.units[SELECTED];
  const isCurrentSel = STATE.current_unit_id === selectedUnit.id;

      // Check if there's a unit at the target position
      const targetUnit = Object.values(STATE.units).find(u =>
        u.alive && u.pos[0] === to[0] && u.pos[1] === to[1]
      );

      if (!isCurrentSel) {
        log(`${selectedUnit.name} is not the active unit. It's ${STATE.units[STATE.current_unit_id]?.name}'s turn.`);
        return;
      }
      let action;
      if (targetUnit && targetUnit.side !== selectedUnit.side) {
        action = {kind: 'ATTACK', attacker_id: SELECTED, target_id: targetUnit.id};
        log(`Attempting to attack ${targetUnit.name}...`);
      } else {
        action = {kind: 'MOVE', unit_id: SELECTED, to: to};
        log(`Attempting to move to ${to[0]},${to[1]}...`);
      }
      await attemptAction(action);
      // Refresh hints after the action
      await fetchLegalAndComputeHints();
      render();
    };
  });
}

async function fetchLegalAndComputeHints() {
  MOVE_HINTS.clear();
  ATTACK_HINTS.clear();
  if (!SID || !SELECTED) return;
  // Only compute hints for the active unit via server legal actions
  if (STATE.current_unit_id !== SELECTED) return;
  try {
    const res = await api(`/sessions/${SID}/legal_actions`);
    LEGAL_ACTIONS = res.actions || [];
  } catch (e) {
    log(`Error fetching legal actions: ${e.message}`, 'error');
    return;
  }
  for (const entry of LEGAL_ACTIONS) {
    const a = entry.action || entry; // backend returns {action, explanation}
    if (a.kind === 'MOVE' && a.unit_id === SELECTED && Array.isArray(a.to)) {
      MOVE_HINTS.add(`${a.to[0]},${a.to[1]}`);
    }
    if (a.kind === 'ATTACK' && a.attacker_id === SELECTED) {
      const tgt = STATE.units[a.target_id];
      if (tgt && tgt.alive) ATTACK_HINTS.set(`${tgt.pos[0]},${tgt.pos[1]}`, tgt.id);
    }
  }
}

// Initialize
updateUI();
document.getElementById('refresh-sessions').onclick = refreshSessions;
document.getElementById('show-sessions').onclick = () => { showSessions(); refreshSessions(); document.getElementById('sessions').scrollIntoView({behavior:'smooth', block:'start'}); };
refreshSessions();
</script>
</body>
</html>
